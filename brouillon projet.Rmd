---
title: "R Notebook"
output: html_notebook
---
Partie I : Breast Cancer Wisconsin (Diagnostic) Data Set

Question 1 : Analyse descriptive, visualisation

```{r}
.libPaths("C:/Users/kluhs/Documents/R/win-library/4.0/librairie")
library(dplyr)
library(ggplot2)
library(readr)

diabetes_prediction_dataset <- read_csv("diabetes_prediction_dataset.csv")

wdbc <- read_csv("wdbc.data", 
                 col_names = c("ID number",
                               "Diagnosis",
                               "radius_mean",
                               "texture_mean",
                               "perimeter_mean",
                               "area_mean","smoothness_mean",
                               "compactness_mean",
                               "concavity_mean",
                               "concave_points_mean",
                               "symmetry_mean",
                               "fractal_dimension_mean",
                               "radius_SE","texture_SE",
                               "perimeter_SE","area_SE",
                               "smoothness_SE",
                               "compactness_SE",
                               "concavity_SE",
                               "concave_points_SE",
                               "symmetry_SE",
                               "fractal_dimension_SE",
                               "radius_worst",
                               "texture_worst",
                               "perimeter_worst",
                               "area_worst",
                               "smoothness_worst",
                               "compactness_worst",
                               "concavity_worst",
                               "concave_points_worst",
                               "symmetry_worst",
                               "fractal_dimension_worst"))
```

```{r}
glimpse(wdbc)
wdbc$Diagnosis <- as.factor(wdbc$Diagnosis)
summary(wdbc)
```
 
graphique pour montrer pertinence entre les variables ?

```{r}
ggplot(
  data = wdbc
) +
  aes(
    x = radius_mean,
    y = perimeter_mean,
    color = Diagnosis
  ) +
  geom_point()+
  theme_classic()
```
Statistiques descriptives bivariées 
```{r}
#Calcul du coefficient de régression linéaire r et de détermination R²
cor.test(wdbc$radius_mean,wdbc$texture_mean)
ggplot(wdbc) +
  aes(
    x = radius_mean,
    y = texture_mean
  ) +
  geom_point()+
  theme_classic()

cor.test(wdbc$radius_mean,wdbc$perimeter_mean)
ggplot(wdbc) +
  aes(
    x = radius_mean,
    y = perimeter_mean
  ) +
  geom_point()+
  theme_classic()

cor.test(wdbc$radius_mean,wdbc$area_mean)
ggplot(wdbc) +
  aes(
    x = radius_mean,
    y = area_mean
  ) +
  geom_point()+
  theme_classic()

```
Partie 2 : data set diabètes 

approche supervisée arbre de décision

```{r}
library(rpart)# Pour l’arbre de décision
library(rpart.plot) # Pour la représentation de l’arbre de décision
```


```{r}

diabetes_prediction_dataset$gender [diabetes_prediction_dataset$gender == "Other"] <- NA
diabetes_prediction_dataset$smoking_history [diabetes_prediction_dataset$smoking_history == "No Info"] <- NA

```

```{r}
glimpse(diabetes_prediction_dataset)
diabetes_prediction_dataset$gender <- as.factor(diabetes_prediction_dataset$gender)
diabetes_prediction_dataset$hypertension <- as.factor(diabetes_prediction_dataset$hypertension)
diabetes_prediction_dataset$heart_disease <- as.factor(diabetes_prediction_dataset$heart_disease)
diabetes_prediction_dataset$heart_disease <- as.factor(diabetes_prediction_dataset$heart_disease)
diabetes_prediction_dataset$smoking_history <- as.factor(diabetes_prediction_dataset$smoking_history)
diabetes_prediction_dataset$diabetes <- as.factor(diabetes_prediction_dataset$diabetes)
summary(diabetes_prediction_dataset)
        

```


```{r}
#Création d’un dataset d’apprentissage et d’un dataset de validation
nb_lignes <- floor((nrow(diabetes_prediction_dataset)*0.75)) #Nombre de lignes de l’échantillon d’apprentissage : 75% du dataset
diabetes_prediction_dataset <- diabetes_prediction_dataset[sample(nrow(diabetes_prediction_dataset)), ] #Ajout de numéros de lignes
diabetes.train <- diabetes_prediction_dataset[1:nb_lignes, ] #Echantillon d’apprentissage
diabetes.test <- diabetes_prediction_dataset[(nb_lignes+1):nrow(ptitanic), ] #Echantillon de test
```

```{r}
#Construction de l’arbre
diabetes.Tree <- rpart(diabetes~.,data=diabetes.train,method= "class", control=rpart.control(minsplit=8,cp=0))

#Affichage du résultat
plot(diabetes.Tree, uniform=TRUE, branch=0.5, margin=0.1)
text(diabetes.Tree, all=FALSE, use.n=TRUE)

#On cherche à minimiser l’erreur pour définir le niveau d’élagage
plotcp(diabetes.Tree)

print(diabetes.Tree$cptable[which.min(diabetes.Tree$cptable[,4]),1])

#Elagage de l’arbre avec le cp optimal
diabetes.Tree_Opt <- prune(diabetes.Tree,cp=diabetes.Tree$cptable[which.min(diabetes.Tree$cptable[,4]),1])

prp(diabetes.Tree_Opt,extra=1)
```


```{r}
#Prédiction du modèle sur les données de test
diabetes.test_Predict<-predict(diabetes.Tree_Opt,newdata=diabetes.test, type= "class")

#Matrice de confusion
mc<-table(diabetes.test$diabetes,diabetes.test_Predict)
print(mc)
```
```{r}
#Erreur de classement
erreur.classement<-1.0-(mc[1,1]+mc[2,2])/sum(mc)
print(erreur.classement)
```
```{r}
#Taux de prédiction
prediction=mc[2,2]/sum(mc[2,])
print(prediction)
```
```{r}
#Affichage des règles de construction de l’arbre
print(diabetes.Tree_Opt)
```
```{r}
# Sélection des variables et standardisation
myvars <- wdbc[,c("radius_mean", "texture_mean", "perimeter_mean","area_mean","smoothness_mean","compactness_mean","concavity_mean","concave_points_mean","symmetry_mean","fractal_dimension_mean")]
myvars <- scale(myvars)

# Calcul de la matrice de distances
mydist <- dist(myvars, method = "euclidean")

# Classification ascendante hiérarchique
myhclust <- hclust(mydist, method = "ward.D2")

# Visualisation du dendrogramme
plot(myhclust)

# Détermination du nombre de groupes à former
mycut <- cutree(myhclust, k = 2)

# Attribution des individus aux groupes correspondants
wdbc$groups <- mycut



# Comparer les étiquettes de classes connues aux groupes obtenus par l'analyse de clustering
install.packages("clValid")
library(clValid)
install.packages('mclust')
library(mclust)
clusters <- cutree(myhclust, k = 2) # groupe obtenu à partir de l'analyse de clustering
ari <- adjustedRandIndex(clusters, wdbc$Diagnosis) # calcul de l'indice de Rand ajusté

# Répéter pour différents nombres de groupes
for (k in 2:6) {
  clusters <- cutree(myhclust, k = k)
  ari <- adjustedRandIndex(clusters, wdbc$Diagnosis)
  print(paste0("ARI pour ", k, " groupes : ", ari))
}
```

```{r}
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.